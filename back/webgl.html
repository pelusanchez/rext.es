<html>
	<head>
		<script id="2d-vertex-shader" type="notjs">
 
		  // an attribute will receive data from a buffer
		  attribute vec4 a_position;
		  attribute vec2 a_texCoord;
		  varying vec2 v_texCoord;


		 
		  // all shaders have a main function
		  void main() {
		 
		    // gl_Position is a special variable a vertex shader
		    // is responsible for setting
		    gl_Position = a_position;

		    // pass the texCoord to the fragment shader
		   // The GPU will interpolate this value between points
		   v_texCoord = a_texCoord;
		  }
		 
		</script>
		 
		<script id="2d-fragment-shader" type="notjs">
		 
		  precision mediump float;
 
			// our texture
			uniform sampler2D u_image;
			 
			// the texCoords passed in from the vertex shader.
			varying vec2 v_texCoord;
			 
			void main() {
			   // Look up a color from the texture.
			   gl_FragColor = texture2D(u_image, v_texCoord);
			}
		 
		</script>
		<script>
			var gl, program, positionBuffer;
			function createShader(gl, type, source) {
			  var shader = gl.createShader(type);
			  gl.shaderSource(shader, source);
			  gl.compileShader(shader);
			  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			  if (success) {
			    return shader;
			  }
			 
			  console.log(gl.getShaderInfoLog(shader));
			  gl.deleteShader(shader);
			}

			function createProgram(gl, vertexShader, fragmentShader) {
			  var program = gl.createProgram();
			  gl.attachShader(program, vertexShader);
			  gl.attachShader(program, fragmentShader);
			  gl.linkProgram(program);
			  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			  if (success) {
			    return program;
			  }
			 
			  console.log(gl.getProgramInfoLog(program));
			  gl.deleteProgram(program);
			}

			function resizeCanvasToDisplaySize(canvas) {
				var multiplier = 1;
				var width  = canvas.clientWidth  * multiplier | 0;
		    var height = canvas.clientHeight * multiplier | 0;
		    if (canvas.width !== width ||  canvas.height !== height) {
		      canvas.width  = width;
		      canvas.height = height;
		      return true;
		    }
			}

			function render(image) {
				// code above this line is initialization code.
			  // code below this line is rendering code.

			  var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
			  
			  resizeCanvasToDisplaySize(gl.canvas);

			  // Tell WebGL how to convert from clip space to pixels
			  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			  // Clear the canvas
			  gl.clearColor(0, 0, 0, 0);
			  gl.clear(gl.COLOR_BUFFER_BIT);

			  // Tell it to use our program (pair of shaders)
			  gl.useProgram(program);

			  				// look up where the vertex data needs to go.
			  var positionLocation = gl.getAttribLocation(program, "a_position");
			  var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

			  // Create a buffer to put three 2d clip space points in
			  var positionBuffer = gl.createBuffer();
			  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
			  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			  // Set a rectangle the same size as the image.
			  setRectangle( gl, 0, 0, image.width, image.height);

			  // provide texture coordinates for the rectangle.
			  var texcoordBuffer = gl.createBuffer();
			  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
			  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			      0.0,  0.0,
			      1.0,  0.0,
			      0.0,  1.0,
			      0.0,  1.0,
			      1.0,  0.0,
			      1.0,  1.0,
			  ]), gl.STATIC_DRAW);

			  // Create a texture.
			  var texture = gl.createTexture();
			  gl.bindTexture(gl.TEXTURE_2D, texture);

			  // Set the parameters so we can render any size image.
			  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			  // Upload the image into the texture.
			  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			}

			function triangle(positions) {
				
				positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);


			  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

			  render();
			}


			function load_image() {
				var image = new Image();
			  image.src = "http://localhost/img.png";  // MUST BE SAME DOMAIN!!!
			  image.onload = function() {
			    render_image(image);
			  };
			}

			function render_image(image) {
				var canvas = document.getElementById("c");
			  gl = canvas.getContext("webgl");
			  if (!gl) {
			    return;
			  }

			  var vertexShaderSource = document.getElementById("2d-vertex-shader").text;
				var fragmentShaderSource = document.getElementById("2d-fragment-shader").text;
				 
				var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
				var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

				program = createProgram(gl, vertexShader, fragmentShader);

				render(image);


				/*triangle([
			    0, 0,
			    0, 0.7,
			    -0.7, 0,
			  ]);*/
			}


function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2,
  ]), gl.STATIC_DRAW);
}

		</script>
	</head>
	<body>
		<canvas id="c"></canvas>
	</body>
</html>