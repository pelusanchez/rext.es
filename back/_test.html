<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script languaje="javascript" src="rgb2hsv.js"></script>
		<script languaje="javascript" src="system_solver.js"></script>
		<style>
			* {
				box-sizing: border-box;
			}

			html, body {
				padding: 0;
				margin: 0;
				width: 100%;
				height: 100%;
				font-family: Arial, sans-serif;
			}
			#canvas {
				width: 100%;
				height: 100%;
				display: flex;
				justify-content: center;
				align-items: center;
				background: #444;
				font-size: 24px;
			}
			#image_main {
				background-color: #000;
			}

			#menu {
				position: fixed;
				left: 0px;
				bottom: 0px;
				top: 0;
				margin: 2px;
				padding: 1px;
				border-right: 1px solid #000;
				background-color: #222222;
				color:#FFF;
			}

			.menu_item {
				display: block;
				margin: 20px 10px;
				text-align: center;
			}

			.menu_item > input {
				display: block;
				margin: 10px;
			}

			/* SLIDER */

			.slider {
			  -webkit-appearance: none;
			  width: 200px;
			  height: 2px;
			  background: #FFF;
			  outline: none;
			  opacity: 0.7;
			  -webkit-transition: .2s;
			  transition: opacity .2s;
			  border-radius: 5px;
			}

			.slider:hover {
			  opacity: 1;
			}

			.slider::-webkit-slider-thumb {
			  -webkit-appearance: none;
			  appearance: none;
			  width: 15px;
			  height: 15px;
			  border-radius: 50%;
			  background: #FFF;
			  cursor: pointer;
			}

			.slider::-moz-range-thumb {
			  width: 20px;
			  height: 20px;
			  border-radius: 50%;
			  background: #C0C0C0;
			  cursor: pointer;
			}
			input[type="file"] {
				display: none;
			}

			#image_main {
				max-width: 80%;
				max-height: 80%;
				transition: opacity 0.2s ease-in-out;
			}

			#image_main.loading {
				opacity: 0.5;
			}
		</style>
		<!-- vertex shader -->
<script id="__VERTEXSHADER" type="GLSL">
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;
uniform float u_Yflip;
varying vec2 v_texCoord;


void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position / u_resolution;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   gl_Position = vec4(clipSpace * vec2(1, u_Yflip), 0, 1);


   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
</script>
<!-- Contrast and brighness -->
<!-- fragment shader -->
<script id="__FRAGMENTSHADER" type="GLSL">
precision mediump float;

// our texture
uniform sampler2D u_image;
uniform vec2 u_textureSize;
uniform float u_kernel[25];
uniform float u_kernelWeight;
uniform vec4 u_colorVec;
uniform float u_lightmatch[256];

uniform float u_saturation;
uniform float u_vibrance;

uniform float u_dehaze;
uniform float u_masking;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

vec4 brightness(vec4 RGB_PIXEL) {
	RGB_PIXEL.r += u_saturation;
	RGB_PIXEL.g += u_saturation;
	RGB_PIXEL.b += u_saturation;
	return RGB_PIXEL;
}

void main() {
  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
  vec4 center = texture2D(u_image, v_texCoord);

  
  vec4 pixel = brightness(center);
  gl_FragColor = pixel;
}
</script>
		<script languaje="javascript">
			var RealImageData, EditImageData;
			var params = {
				brightness: 0, // [0-100]
				saturation: 0, // [0-100]
				contrast: 0, // [0-100]
				vibrance: 0,
				sharpen: 0,
				masking: 0.5,
				sharpen_radius: 1,
				radiance: 0,
				highlights: 0.66,
				shadows: 0.33,
				whites: 1,
				blacks: 0,
				dehaze: 0
			};
			

			var defaultParams = {
				brightness: 0, // [0-100]
				saturation: 0, // [0-100]
				constrast: 0, // [0-100]
				vibrance: 0
			};

			var PROCESSING = false;

			var imageElm, imageCtx; // Editor image element and image context

			var WIDTH, HEIGHT; // Editor image WIDTH and HEIGHT, may be less than real image



			// Get image without edition (saved in process_image canvas)
			function getProcessImage() {
				return document.getElementById("process_image").getContext("2d").getImageData(0, 0, WIDTH, HEIGHT);
			}


			/* VIBRANCE */
			var vibranceArr = [];
			var updateVibranceArray = (vib) => {
				vibranceArr = [];
				for (var i = 0; i <= 256; i++) {
					vibranceArr[i] = Math.pow(i / 256, 50 / vib);
				}
			}

			function vibFunction(s) {
				return vibranceArr[parseInt(s * 256)] || s;
			}

			/* CONTRAST */


			async function updatePhoto(prop, val) {
				params[prop] = val;
			}

			// WEBGL PART ======================================
"use strict";

// Editions made in the image
var editions = [];

var IMAGE_CONVOLUTION_KERNEL = [0,0,0,0,0, 0,0,0,0,0 ,0,0,1,0,0, 0,0,0,0,0 ,0,0,0,0,0];

var WIDTH, HEIGHT;

var textures = [];
var framebuffers = [];

function main() {
  var image = new Image();
  image.src = "http://localhost/img.png";  // MUST BE SAME DOMAIN!!!
  image.onload = function() {
    render(image);
  };
}

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
 
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  var width  = canvas.clientWidth  * multiplier | 0;
  var height = canvas.clientHeight * multiplier | 0;
  if (canvas.width !== width ||  canvas.height !== height) {
    canvas.width  = width;
    canvas.height = height;
    return true;
  }
  return false;
}

function createTexture(gl) {
  var texture = gl.createTexture();

  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Set the parameters so we can render any size image.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  return texture;
}

var Matrix = Matrix || {};
Matrix.inv_matrix = function(mat) {
	
}



function kernel_update() {
	// 3x3 kernel
	var sharpness = - params.sharpen;
	var radius = params.sharpen_radius;
	
	if (params.radiance != 0) {
		sharpness -= 0.5 * params.radiance;
		radius += 0.5 * params.radiance;
	}

	var A = sharpness * Math.exp(- Math.pow(1    / radius, 2)); 
	var B = sharpness * Math.exp(- Math.pow(1.41 / radius, 2));
	var C = sharpness * Math.exp(- Math.pow(2    / radius, 2));
	var D = sharpness * Math.exp(- Math.pow(2.24 / radius, 2));
	var E = sharpness * Math.exp(- Math.pow(2.83 / radius, 2));
	var X = 1;
	if (sharpness < 0) {
		X += 4 * Math.abs(E) + 8 * Math.abs(D) + 4 * Math.abs(C) + 4 * Math.abs(B) + 4 * Math.abs(A);
	}

	IMAGE_CONVOLUTION_KERNEL = [E, D, C, D, E,
															D, B, A, B, D,
															C, A, X, A, C,
															D, B, A, B, D,
															E, D, C, D, E];
}


var LIGHT_MATCH = (function() {
	var _r = [];
	for (var i = 0; i < 256; i++) {
		_r[i] = i / 256;
	}
	return _r;
})();

/**
 * Lightning generation:
 * Map brightness values depending on Brightness, Contrast... etc
 */
function generateLightning() {
	var f = getCuadraticFunction(
			params.blacks,
			params.shadows,
			params.highlights,
			params.whites,
			0, 0.33, 0.66, 1);


	// Radiance part
	if (params.radiance != 0) {
		var f_radiance = getCuadraticFunction(
			0,
			0.33 - params.radiance * 0.11,
			0.66 + params.radiance * 0.11,
			1,
			0, 0.33, 0.66, 1);
	}

	var kontrast = (params.contrast + 1.0);
	for (var i = 0; i < 256; i++) {
		var pixel_value = i / 256;

		// Brightness
		pixel_value += params.brightness;
		if (pixel_value > 1) { pixel_value = 1; }
		if (pixel_value < 0) { pixel_value = 0; }
		// Contrast
		pixel_value = kontrast * (pixel_value - 0.5) + 0.5;

		if (pixel_value > 1) { pixel_value = 1; }
		if (pixel_value < 0) { pixel_value = 0; }
		
		if (f_radiance) {
			pixel_value = f_radiance(pixel_value);
		}

		LIGHT_MATCH[i] = f(pixel_value); //f(pixel_value);
	}
}

function computeKernelWeight(kernel) {
  var weight = kernel.reduce(function(prev, curr) {
      return prev + curr;
  });
  return weight;
}
function render(image) {
	imageElm.width = image.width;
	imageElm.height = image.height;
  if (!window.gl) {
    return;
  }


  // setup GLSL program
  window.program = createProgram(gl,
    createShader(gl, gl.VERTEX_SHADER, document.getElementById("__VERTEXSHADER").text), 
    createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("__FRAGMENTSHADER").text));

  // look up where the vertex data needs to go.
  var positionLocation = gl.getAttribLocation(program, "a_position");
  var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

  

  // Create a buffer to put three 2d clip space points in
  var positionBuffer = gl.createBuffer();
  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  
  // Set a rectangle the same size as the image.
  WIDTH = image.width;
  HEIGHT = image.height;
  while (WIDTH * HEIGHT > 1000000) {
  	WIDTH /= 2;
  	HEIGHT /= 2;
  }
  imageElm.width = WIDTH;
  imageElm.height = HEIGHT;
  setRectangle( gl, 0, 0, WIDTH, HEIGHT);

  // provide texture coordinates for the rectangle.
  var texcoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      0.0,  0.0,
      1.0,  0.0,
      0.0,  1.0,
      0.0,  1.0,
      1.0,  0.0,
      1.0,  1.0,
  ]), gl.STATIC_DRAW);

  // Create a texture.
  
  window.updatePhoto = function() {
  	update();
  }


  // create 2 textures and attach them to framebuffers.

  var originalImageTexture = createTexture(gl);
  // Upload the image into the texture.
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
//  gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);


  // lookup uniforms
  var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
  var textureSizeLocation = gl.getUniformLocation(program, "u_textureSize");
  var kernelLocation = gl.getUniformLocation(program, "u_kernel[0]");
  var u_lightmatch = gl.getUniformLocation(program, "u_lightmatch[0]");
  var kernelWeightLocation = gl.getUniformLocation(program, "u_kernelWeight");
  var flipY = gl.getUniformLocation(program, "u_Yflip");
  var u_colorVec = gl.getUniformLocation(program, "u_colorVec");
  //var u_brightness = gl.getUniformLocation(program, "u_brightness");
  //var u_contrast = gl.getUniformLocation(program, "u_contrast");
  var u_vibrance = gl.getUniformLocation(program, "u_vibrance");
  var u_saturation = gl.getUniformLocation(program, "u_saturation");
  var u_masking = gl.getUniformLocation(program, "u_masking");
  var u_dehaze = gl.getUniformLocation(program, "u_dehaze");
  
  var u_option = gl.getUniformLocation(program, "u_option");
  var u_value = gl.getUniformLocation(program, "u_value");
  
  
  

  update();

  

  window.changeContrast = function() {
    update();
  }

  function update() {
    
    //resizeCanvasToDisplaySize(gl.canvas);

    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(0, 0, WIDTH, HEIGHT);

    // Clear the canvas
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Tell it to use our program (pair of shaders)
    gl.useProgram(program);

    // Turn on the position attribute
    gl.enableVertexAttribArray(positionLocation);

    // Bind the position buffer.
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 2;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        positionLocation, size, type, normalize, stride, offset);

    // Turn on the teccord attribute
    gl.enableVertexAttribArray(texcoordLocation);

    // Bind the position buffer.
    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

    // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 2;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        texcoordLocation, size, type, normalize, stride, offset);

    // set the resolution
    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

    // set the size of the image
    gl.uniform2f(textureSizeLocation, WIDTH, HEIGHT);

    // Set the color
    gl.uniform4f(u_colorVec, 1, 1, 1, 1);

    // Set the contrast
    //gl.uniform1f(u_brightness, params.brightness);
    //gl.uniform1f(u_contrast, params.contrast);
    gl.uniform1f(u_saturation, params.saturation);
    gl.uniform1f(u_vibrance, 1 - params.vibrance);
    gl.uniform1f(u_masking, params.masking);
    gl.uniform1f(u_dehaze, params.dehaze);

    /*gl.uniform1f(u_splines, Matrix.inv_matrix([ 0, 0, 0, 1,
    													0.035937, 0.10890, 0.33, 1,
    													0.28750, 0.43560, 0.66, 1,
    													1, 1, 1, 1]));*/
    gl.uniform1fv(u_lightmatch, LIGHT_MATCH);
    // Show image
    gl.uniform1f(flipY, -1);

    
    // set the kernel and it's weight
    gl.uniform1fv(kernelLocation, IMAGE_CONVOLUTION_KERNEL);
    
    gl.uniform1f(kernelWeightLocation, computeKernelWeight(IMAGE_CONVOLUTION_KERNEL ));

    // Draw the rectangle.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
}

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2,
  ]), gl.STATIC_DRAW);
}

			// END WEBGL PART==================================================
			function loadImageFromUrl(url) {
				const img = new Image();
				img.src = url;
				img.onload = function() {
					render(img);
				}
			}

			window.onload = function() {
				imageElm = document.getElementById("image_main");
				window.gl = imageElm.getContext("webgl");
				imageElm.addEventListener("click", () => {
					document.getElementById("image_data").click();
				})
				document.getElementById("image_data").addEventListener("change", () => {
					let imageReader = new FileReader();
					loadImageFromUrl(URL.createObjectURL(event.target.files[0]))
				})

				loadImageFromUrl("http://localhost/img.jpg");

				var sliders = document.getElementsByClassName("slider");
				var i = sliders.length;
				while (i--) {
					sliders[i].addEventListener("input", function(event) {
						if (PROCESSING) { return; }
						
						params[this.getAttribute("data")] = parseFloat(this.value);
						if (this.getAttribute("data-callback")) {
							var args = this.getAttribute("data-callback").split(",");
							args.forEach(arg => {
								window[arg]();
							})
							
						}
						updatePhoto();
					})
				}
			}
		</script>
	</head>
	<body>
		<div id="menu">
			<div class="menu_item">
				Brillo
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="brightness" data-callback="generateLightning">
			</div>
			<div class="menu_item">
				Contraste
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="contrast" data-callback="generateLightning">
			</div>
			<div class="menu_item">
				Saturación
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="saturation">
			</div>
			<div class="menu_item">
				Vibrancia
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="vibrance">
			</div>

			<div class="menu_item">
				Resplandor
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="radiance" data-callback="generateLightning,kernel_update">
			</div>

			<div class="menu_item">
				Niebla
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="dehaze">
			</div>

			<div class="menu_item">
				Detalles
				<input type="range" step="0.01" min="-1" max="1" value="0" class="slider" data="sharpen" data-callback="kernel_update">
			</div>

			<div class="menu_item">
				Radio
				<input type="range" step="0.01" min="0.1" max="2" value="1" class="slider" data="sharpen_radius" data-callback="kernel_update">
			</div>
			
			<div class="menu_item">
				Máscara
				<input type="range" step="0.01" min="0" max="1" value="0.5" class="slider" data="masking">
			</div>

			<div class="menu_item">
				Blancos
				<input type="range" step="0.01" min="0" max="1" value="1" class="slider" data="whites" data-callback="generateLightning">
			</div>

			<div class="menu_item">
				Luces
				<input type="range" step="0.01" min="0" max="1" value="0.66" class="slider" data="highlights" data-callback="generateLightning">
			</div>

			<div class="menu_item">
				Sombras
				<input type="range" step="0.01" min="0" max="1" value="0.33" class="slider" data="shadows" data-callback="generateLightning">
			</div>

			<div class="menu_item">
				Negros
				<input type="range" step="0.01" min="0" max="1" value="0" class="slider" data="blacks" data-callback="generateLightning">
			</div>
			
		</div>
		<div id="canvas">
			<canvas id="image_main" width="400" height="400"></canvas>
			<canvas id="real_image" style="display: none" width="400" height="400"></canvas>
			<canvas id="process_image" style="display: none" width="400" height="400"></canvas>
		</div>
		<input type="file" id="image_data">
	</body>
</html>