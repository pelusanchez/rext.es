(function(__window) {
  "use strict";

  var EDITION_RESOLUTION_LIMIT = 2000000;
  __window.requestAnimationFrame = __window.requestAnimationFrame ||
                              __window.mozRequestAnimationFrame ||
                              __window.webkitRequestAnimationFrame || 
                              __window.msRequestAnimationFrame || 
                              function(fn) { setTimeout(fn, 20); };

  function clamp(a, b, c) {
    return (a < b) ? b : (a > c) ? c : a;
  }

  function hsv2rgb(pixel_hsv){
    var a, d, c;
    var r, g, b;

    a = pixel_hsv[2] * pixel_hsv[1];
    d = a * (1.0 - Math.abs( (pixel_hsv[0] / 60.0) % 2.0 - 1.0));
    c = pixel_hsv[2] - a;

    
    // Fastest way?
    if (pixel_hsv[0] < 180.0) {
      if (pixel_hsv[0] < 60.0) {
        r = pixel_hsv[2];
        g = d + c;
        b = c;
      } else if (pixel_hsv[0] < 120.0) {
        r = d + c;
        g = pixel_hsv[2];
        b = c;
      } else {
        r = c;
        g = pixel_hsv[2];
        b = d + c;
      }
    } else {
      if (pixel_hsv[0] < 240.0) {
        r = c;
        g = d + c;
        b = pixel_hsv[2];
      } else if(pixel_hsv[0] < 300.0) {
        r = d + c;
        g = c;
        b = a + c;
      } else {
        r = a + c;
        g = c;
        b = d + c;
      }
    }

    r = clamp(r, 0.0, 1.0);
    g = clamp(g, 0.0, 1.0);
    b = clamp(b, 0.0, 1.0);

    return [r, g, b];
  }

  



  // WEBGL PART ======================================  

  var PROCESSING = false;

  var realImage = null;

  var temptint = [1, 1, 1]; // Temperature and Tint RGB channels (multipliers of R, G and B)

  var IMAGE_CONVOLUTION_KERNEL = [0,0,0,0,0, 0,0,0,0,0 ,0,0,1,0,0, 0,0,0,0,0 ,0,0,0,0,0];


  function getLuma(rgb_pix) {
    return 0.2126 * rgb_pix.r + 0.7152 * rgb_pix.g + 0.0722 * rgb_pix.b;
  }



  function __ERROR(m) {
    Popup.show({
      header: 'Se ha producido un error',
      body: m
    });
  }

  function isMobile() {
    return /mobile|android|iphone|ipad|ipod|kindle|symbian/i.test(navigator.userAgent||navigator.vendor||__window.opera);
  }

 /* BEGIN WEBGL PART */

  function createShader(gl, type, source) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
      return shader;
    }
   
    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
  }


  function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
      return program;
    }
   
    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    __ERROR("createProgram Error");
  }


  function createTexture(gl) {
    var texture = gl.createTexture();

    gl.bindTexture(gl.TEXTURE_2D, texture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    return texture;
  }




  /* DATA CALLBACKS */
  var DATA_CALLBACK = DATA_CALLBACK || {};

  DATA_CALLBACK.kernel_update = function () {
  	// 3x3 kernel
  	var sharpness = - Params.get('sharpen');
  	var radius = Params.get('sharpen_radius');
    var radiance = Params.get('radiance');
    var hdr = Params.get('hdr');
  	
  	if (radiance != 0) {
  		sharpness -= 0.5 * radiance;
  		radius += 0.5 *  radiance;
  	}

    if (hdr != 0) {
      sharpness -= 0.5 * hdr;
      radius += 0.5 * hdr;
    }

  	var A = sharpness * Math.exp(- Math.pow(1    / radius, 2)); 
  	var B = sharpness * Math.exp(- Math.pow(1.41 / radius, 2));
  	var C = sharpness * Math.exp(- Math.pow(2    / radius, 2));
  	var D = sharpness * Math.exp(- Math.pow(2.24 / radius, 2));
  	var E = sharpness * Math.exp(- Math.pow(2.83 / radius, 2));
  	var X = 1;
  	if (sharpness < 0) {
  		X += 4 * Math.abs(E) + 8 * Math.abs(D) + 4 * Math.abs(C) + 4 * Math.abs(B) + 4 * Math.abs(A);
  	}

  	IMAGE_CONVOLUTION_KERNEL = [E, D, C, D, E,
  															D, B, A, B, D,
  															C, A, X, A, C,
  															D, B, A, B, D,
  															E, D, C, D, E];
  }


  // Temp and Tint
  DATA_CALLBACK.updateTemptint = function () { // Temperature in kelvin
    var T = Params.get('temperature')
    var tint = Params.get('tint')

    if (T < 0) {
      var __TEMP_DATA = [[0.6167426069865002, 0.017657981710823077],[0.5838624982041293, 0.06447754787874993],[0.5666570157784903, 0.1010769359975838],[0.5600215017846518, 0.13012054359808795],[0.5603460901328465, 0.15370282338343416],[0.5651414015638195, 0.1734071109259789],[0.5727157905223393, 0.19040417876076665],[0.5819305919306469, 0.20554787970182647],[0.5920253173976543, 0.219454396860673],[0.6024964973113273, 0.23256361077001078],[0.613014923688415, 0.2451851574423344],[0.6233694681448863, 0.2575325541865392],[0.633428991849502, 0.2697484189519574],[0.6431164873163056, 0.2819231700046263],[0.6523914777767198, 0.29410898225476145],[0.6612380004437802, 0.30633028466830314],[0.6696563786680246, 0.31859171532935343],[0.6776575761390952, 0.330884185957384],[0.6852593188363603, 0.34318952105568623],[0.6924834326806721, 0.3554840067292358],[0.6993540206164168, 0.36774109382812364],[0.705896221219359, 0.37993343721079975],[0.712135371070854, 0.3920344089104195],[0.7180964477199883, 0.4040191918024166],[0.7238037074478182, 0.41586553788423575],[0.7292804578150028, 0.42755425869079605],[0.7345489228275083, 0.43906950280216533],[0.7396301709912545, 0.4503988656030025],[0.7445440852278651, 0.4615333686006381],[0.7493093597375261, 0.47246733915721345],[0.7539435132044948, 0.4831982160881075],[0.7584629107855697, 0.4937263019887011],[0.7628827894765442, 0.5040544792219176],[0.7672172829757861, 0.5141879031216875],[0.7756812566990368, 0.5339005596070674],[0.7756812566990368, 0.5339005596070674],[0.7798336535847834, 0.5434985836882681],[0.7839465092903851, 0.552938802301879],[0.7880286368234596, 0.5622329533372938],[0.7920877696863722, 0.5713931712543325],[0.796130534601134, 0.5804317041849897],[0.8001624136045166, 0.5893606423074715],[0.8041876951180534, 0.5981916567442426],[0.8082094136732589, 0.6069357478075997],[0.8122292780585781, 0.6156030011340633],[0.8162475877574743, 0.624202350096731],[0.8202631376804659, 0.6327413428542148],[0.8242731113661302, 0.6412259124772712],[0.8282729630469863, 0.6496601487868902],[0.8322562892583072, 0.6580460708395705],[0.8362146910181553, 0.6663833994084263],[0.8401376280395388, 0.6746693293369075],[0.8440122669563406, 0.6828983022904387],[0.8478233261635671, 0.691061781205187],[0.8515529205921868, 0.6991480286361483],[0.8578515274860328, 0.7143328511178657],[0.8630349166004683, 0.7236145588845],[0.8630349166004683, 0.7236145588845],[0.8678866519883774, 0.7326305266929798],[0.8724265417351438, 0.7413920824039555],[0.8766746938112879, 0.7499106260961086],[0.8806514255414362, 0.7581975699581189],[0.8843771730729832, 0.7662642858505886],[0.8878724008449614, 0.7741220599147951],[0.8911575110568668, 0.7817820536219475],[0.8942527531374216, 0.7892552706795768],[0.8971781332133792, 0.7965525292390034],[0.9025975721615955, 0.8106613818669473],[0.9051296119968262, 0.8174934982533621],[0.9051296119968262, 0.8174934982533621],[0.9075675706910422, 0.8241906743465228],[0.9099288798932852, 0.8307625342003426],[0.912230184763394, 0.8372184337382709],[0.914487253441016, 0.8435674571884941],[0.9167148865142485, 0.8498184155292972],[0.9189268264883301, 0.8559798466723794],[0.9211356672547586, 0.862060017138353],[0.9233527635598611, 0.8680669250033681],[0.9278504028585166, 0.8798916280267886],[0.9301466448383797, 0.8857241176152066],[0.9324823592671754, 0.8915127453709542],[0.9348613471976668, 0.8972642431099969],[0.9348613471976668, 0.8972642431099969],[0.9372856273504615, 0.9029851088748369],[0.9397553455825536, 0.9086816143048344],[0.9422686843563701, 0.9143598121965675],[0.9448217722084058, 0.9200255441824128],[0.947408593218177, 0.925684448465339],[0.9500208964767429, 0.931341967556689],[0.9552772279767501, 0.9426736878435626],[0.9578927646784257, 0.9483578644262163],[0.9604766194871308, 0.954060621455171],[0.9630080085847714, 0.9597865363484674],[0.965463369977889, 0.9655400352277332],[0.965463369977889, 0.9655400352277332],[0.9678162729662736, 0.9713253997462401],[0.9700373276119754, 0.9771467737131783],[0.9720940942080452, 0.9830081695063213],[0.9739509927471266, 0.9889134742677088],[0.97556921239073, 0.9948664558790756],[0.9782396416593983, 1]];
      R = 1;
      var i = __TEMP_DATA[parseInt((T + 1) * 100) ];
      G = i[0];
      B = i[1];
    } else {
      R = 0.0438785 / (Math.pow(T + 0.150127, 1.23675)) + 0.543991;
      G = 0.0305003 / (Math.pow(T + 0.163976, 1.23965)) + 0.69136;
      B = 1;
    }

    if (tint == -1) {
      tint = -0.99;
    }

    G += tint;


    // Luma correction
    var curr_luma = getLuma({r: R, g: G, b: B});
    var mult_K = 1 / curr_luma;

    temptint = [R * mult_K, G * mult_K, B * mult_K];


  }

  var LIGHT_MATCH = (function() {
  	var _r = [];
  	for (var i = 0; i < 256; i++) {
  		_r[i] = i;
  	}
  	return _r;
  })();

  /**
   * Lightning generation:
   * Map brightness values depending on Brightness, Contrast... etc
   */
  DATA_CALLBACK.generateLightning = function () {
    var blacks = Params.get('blacks');
    var shadows = Params.get('shadows');
    var highlights = Params.get('highlights');
    var whites = Params.get('whites');
    var radiance = Params.get('radiance');
  	var f = getCuadraticFunction(
  			blacks,
  			shadows + 0.33,
  			highlights + 0.66,
  			whites + 1,
  			0,  0.33, 0.66, 1);


  	// Radiance part
  	if (radiance != 0) {
  		var f_radiance = getCuadraticFunction(
  			0,
  			0.33 - radiance * 0.11,
  			0.66 + radiance * 0.11,
  			1,
  			0, 0.33, 0.66, 1);
  	}

  	//var kontrast = (params.contrast + 1.0);
  	for (var i = 0; i < 256; i++) {
  		var pixel_value = i / 256;

  		// Brightness
  		//pixel_value += params.brightness;
  		if (pixel_value > 1) { pixel_value = 1; }
  		if (pixel_value < 0) { pixel_value = 0; }
  		// Contrast
  		//pixel_value = kontrast * (pixel_value - 0.5) + 0.5;

  		if (pixel_value > 1) { pixel_value = 1; }
  		if (pixel_value < 0) { pixel_value = 0; }
  		
  		if (f_radiance) {
  			pixel_value = f_radiance(pixel_value);
  		}
  		pixel_value = f(pixel_value);
  		if (pixel_value > 1) { pixel_value = 1; }
  		if (pixel_value < 0) { pixel_value = 0; }
  		LIGHT_MATCH[i] =  pixel_value * 255; //f(pixel_value);
  	}
  }

  /**
   * kernelNormalization
   * Compute the total weight of the kernel in order to normalize it
   */
  function kernelNormalization(kernel) {
    return kernel.reduce(function(a, b) { return a + b; });
  }

  /**
   * render
   * Prepare the environment to edit the image
   * image: Image element to edit (Image object)
   * context: webgl context. Default: __window.gl
   * SET_FULL_RES: no resize the image to edit. Default: false (resize the image)
   */


  function render(image, context, preventRenderImage) {

    var gl = context || __window.__gl;
    
    // Load GSLS programs

    var __VSS = createShader(gl, gl.VERTEX_SHADER, __SHADERS__.VERTEX);
    
  	var __FSS = createShader(gl, gl.FRAGMENT_SHADER, __SHADERS__.FRAGMENT);

    try {
    	var program = createProgram(gl,
      	__VSS, 
      	__FSS);
    } catch(err) {
    	return __ERROR(err);
    }

    // look up where the vertex data needs to go.
    var positionLocation = gl.getAttribLocation(program, "a_position");
    var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

    // Create a buffer to put three 2d clip space points in
    var positionBuffer = gl.createBuffer();

    // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    
    // Set a rectangle the same size as the image.
    var WIDTH = image.width;
    var HEIGHT = image.height;
    gl.canvas.width = WIDTH;
    gl.canvas.height = HEIGHT;

    console.log("[IMAGE] width = " + WIDTH + ", height = " + HEIGHT);

    setRectangle(gl, 0, 0, WIDTH, HEIGHT);

    // Create the rectangle 
    var texcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0,  0.0,
        1.0,  0.0,
        0.0,  1.0,
        0.0,  1.0,
        1.0,  0.0,
        1.0,  1.0,
    ]), gl.STATIC_DRAW);
  	


  	gl.activeTexture(gl.TEXTURE0);

    var originalImageTexture = createTexture(gl);
    // Upload the image into the texture.
    try {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    } catch(err) {
      return __ERROR(err);
    }

    var u_image = gl.getUniformLocation(program, "u_image");
  	

    // lookup uniforms
    var resolutionLocation    = gl.getUniformLocation(program, "u_resolution");
    var textureSizeLocation   = gl.getUniformLocation(program, "u_textureSize");
    var kernelLocation        = gl.getUniformLocation(program, "u_kernel[0]");
    var kernelWeightLocation  = gl.getUniformLocation(program, "u_kernelWeight");
    var u_exposure            = gl.getUniformLocation(program, "u_exposure");
    var u_brightness          = gl.getUniformLocation(program, "u_brightness");
    var u_contrast            = gl.getUniformLocation(program, "u_contrast");
    var u_saturation          = gl.getUniformLocation(program, "u_saturation");
    var u_masking             = gl.getUniformLocation(program, "u_masking");
    var u_dehaze              = gl.getUniformLocation(program, "u_dehaze");
    var u_atmosferic_light    = gl.getUniformLocation(program, "u_atmosferic_light");
    var u_temptint            = gl.getUniformLocation(program, "u_temptint[0]");
    var u_bAndW               = gl.getUniformLocation(program, "u_bAndW");
    var u_hdr                 = gl.getUniformLocation(program, "u_hdr");

    var u_lut = gl.getUniformLocation(program, "u_lut");
    // Upload the LUT (contrast, brightness...)
    gl.activeTexture(gl.TEXTURE1);

    var LUTTexture = createTexture(gl);
    
    
    
    __window.updatePhoto = function() {
    	return update();
    }

    // Tell WebGL how to convert from clip space to pixels

    

    gl.viewport(0, 0, WIDTH, HEIGHT);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    if (!preventRenderImage) { update(); }

    function update() {

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, 256, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE,
          new Uint8Array(LIGHT_MATCH));

      // Tell it to use our program (pair of shaders)
      gl.useProgram(program);

      // Turn on the position attribute
      gl.enableVertexAttribArray(positionLocation);

      // Bind the position buffer.
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      // Turn on the teccord attribute
      gl.enableVertexAttribArray(texcoordLocation);

      // Bind the position buffer.
      gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

      gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

      // set the resolution
      gl.uniform2f(resolutionLocation, WIDTH, HEIGHT); //gl.canvas.width, gl.canvas.height);

      // set the size of the image
      gl.uniform2f(textureSizeLocation, WIDTH, HEIGHT);

      // Set the contrast
      gl.uniform1f(u_brightness, Params.get('brightness'));
      //gl.uniform1f(u_contrast, Params.get('contrast);
      gl.uniform1f(u_exposure, Params.get('exposure'));
      gl.uniform1f(u_contrast, Params.get('contrast'));
      gl.uniform1f(u_saturation, Params.get('saturation'));
      gl.uniform1f(u_masking, Params.get('masking'));
      gl.uniform1f(u_dehaze, Params.get('dehaze'));
      gl.uniform1f(u_atmosferic_light, Params.get('atmosferic_light'));
      gl.uniform3fv(u_temptint,
        temptint
        .concat(hsv2rgb([Params.get('lightColor') * 360, Params.get('lightSat'), Params.get('lightFill')]))
        .concat(hsv2rgb([Params.get('darkColor') * 360, Params.get('darkSat'), Params.get('darkFill')]))); // vec3 x3
      gl.uniform1f(u_bAndW, Params.get('bAndW'));
      gl.uniform1f(u_hdr, Params.get('hdr'));

      // Show image
      gl.uniform1i(u_image, 0); // TEXTURE 0
  		gl.uniform1i(u_lut, 1); // TEXTURE 1

      
      // set the kernel and it's weight
      gl.uniform1fv(kernelLocation, IMAGE_CONVOLUTION_KERNEL);
      gl.uniform1f(kernelWeightLocation, kernelNormalization(IMAGE_CONVOLUTION_KERNEL));

      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
  }

  function setRectangle(gl, x, y, width, height) {
    var x1 = x;
    var x2 = x + width;
    var y1 = y;
    var y2 = y + height;
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
       x1, y1,
       x2, y1,
       x1, y2,
       x1, y2,
       x2, y1,
       x2, y2,
    ]), gl.STATIC_DRAW);
  }

  // END WEBGL PART==================================================

  function loadImageFromUrl(url) {
    var loaderHandler = UI.loadingHandler();
    // Save real image as a copy
  	realImage = new Image();
  	realImage.src = url;

    var RESOLUTION_LIMIT = 10000000;
    realImage.onload = function() {
      if (realImage.width * realImage.height > RESOLUTION_LIMIT) {
        var K = realImage.height / realImage.width;
        realImage.height = parseInt(Math.sqrt(K * RESOLUTION_LIMIT));
        realImage.width = parseInt(realImage.height / K);
      }
    }
    var img = new Image();
    // Some JPG files are not accepted by graphic card,
    // the following code are to convert it to png image
    img.onerror = () => {
      loaderHandler.end();
      __ERROR("Error al cargar la imagen.")
    }

    img.onload = function() {
      loaderHandler.set(30);
      try {
        var canvas = document.createElement("canvas");

        if (img.height * img.width > EDITION_RESOLUTION_LIMIT) {
          var _H = Math.sqrt(EDITION_RESOLUTION_LIMIT * img.height / img.width);
          var _W = img.width / img.height * _H;
          canvas.width = _W;
          canvas.height = _H;
        } else {
          canvas.width = img.width;
          canvas.height = img.height;
        }

        loaderHandler.set(40);

        var resizeImageCanvas = canvas.getContext("2d");
        resizeImageCanvas.imageSmoothingEnabled = 1;
        resizeImageCanvas.drawImage(img, 0, 0, canvas.width, canvas.height);
        loaderHandler.set(60);

        var _img = new Image();
        _img.src = canvas.toDataURL("image/png");
        loaderHandler.set(80);

        _img.onload = function() {
          loaderHandler.end();
          UI.setImageLoaded(true);
          render(_img, __window.gl);
        }
        
      } catch(err) {
        __ERROR(err);
        loaderHandler.end();
      }
    }
    
    img.src = url;

    loaderHandler.set(20);
  }


  /* BOOT CODE */
  var __BOOT__ = function() {

  	imageElm = document.getElementById("image_main");
  	__window.__gl = imageElm.getContext("webgl") || imageElm.getContext("experimental-webgl");
  	if (!__window.__gl) {
  		alert("Error: No webgl detected");
  	}

  	document.getElementById("image_data").addEventListener("change", (e) => {
      e = e || __window.event
      let imageReader = new FileReader();
      if (e.target.files[0]) {
        loadImageFromUrl(URL.createObjectURL(e.target.files[0]))
      }
  	})

  	var sliders = document.getElementsByClassName("slider");
  	var i = sliders.length;
  	while (i--) {
  		sliders[i].addEventListener("input", Actions.sliderCallback);
  	}
  };

  /* Actions Class */

  var Actions = Actions || {};

  // Reset params
  Actions.reset = function () {
    
    // Ask user if are sure
    if (!confirm("Desea reiniciar los ajustes?")) {
      return;
    }

    // Reset params
    Params.reset();

    // Reset sliders
    var ranges = document.getElementsByClassName("range");
    var i = ranges.length;
    while (i--) {
      var currentData = ranges[i].getAttribute("data");
      ranges[i].value = Params.get(currentData);
      if (ranges[i].getAttribute("data-callback")) {
        Actions.callCallbacks(ranges[i].getAttribute("data-callback"));
      }
    }
    // Callbacks!!

    // Update the photo
    updatePhoto();
  }

  // Download the photography

  Actions.downloadSecondStep = function() {

    var filename = document.getElementById("image-name").value;
    Popup.hide();
    if (!filename) {
      filename = 'image';
    }

    filename += '.jpg'; // Add extension
    var loaderHandler = UI.loadingHandler();

    var renderCanvas = document.getElementById("image_main");

    renderCanvas.width = realImage.width;
    renderCanvas.height = realImage.height;

    loaderHandler.set(10);
    render(realImage,  __window.__gl, true);
    loaderHandler.set(40);
    
    setTimeout(function() {
      loaderHandler.set(70);
      updatePhoto();
      renderCanvas.toBlob(function(blob) {
        loaderHandler.set(90);
        var url = URL.createObjectURL(blob);
        var dlLink = document.createElement("a");
        dlLink.href = url; //.replace(/^data:image\/[^;]+/, 'data:application/octet-stream');
        dlLink.download = filename;
        document.body.append(dlLink);
        dlLink.click();
        document.body.removeChild(dlLink);
        URL.revokeObjectURL(url);
        blob = null; // This would clean?
        setTimeout(function() {
          loaderHandler.end();
          render(realImage);
        }, 2000);
      }, "image/jpeg", 0.95);

    }, 2000);

  }
  Actions.download = function() {
    
    Popup.show({
      header: Locale.get("image_save_title"),
      bodyHTML: Locale.get("image_save_text") + `<br><input type="text" id="image-name" placeholder="Nombre de la imagen">`,
      onEnterCallback: Actions.downloadSecondStep,
      buttons: [
        { text: 'Aceptar', callback: Actions.downloadSecondStep },
      ]
    }).then(() => {
      document.getElementById("image-name").focus();
    })

  }

  Actions.callCallbacks = function(callbacks) {
    var callback = callbacks.split(",");
    callback.forEach(cb => {
      DATA_CALLBACK[cb]();
    })
  }

  Actions.setParam = function(args) {
    if (!UI.isImageLoaded()) {
      return __ERROR(Locale.get("image_no_loaded"))
    }

    var amountElm = document.getElementById("cantidad")
    if (amountElm) {
      amountElm.innerHTML = Locale.get(args.paramName) + ": " + Math.round(args.value * 100) / 100;
    }
 

    if (args.save) {
      Actions.history.push({
        paramName: args.paramName,
        value: Params.get(args.paramName), // Save last value
        callbacks: args.callbacks
      });
    }

    Params.set(args.paramName, args.value);
    if (args.callbacks) {
      Actions.callCallbacks(args.callbacks);
    }
    
    updatePhoto();
  }


  Actions.timeOutSliderInfo = null;

  Actions.sliderCallback = function(evt) {
    
    evt = evt || __window.event;
    Actions.setParam({
      paramName: this.getAttribute("data"),
      value: this.value,
      callbacks: this.getAttribute("data-callback"),
      save: true
    });

  }
  
  // 
  Actions.history = {
    hist: [],   // History
    currCur: 0, // Current cursor of history
    push: function(args) {
      // Save only once, when current cursor are greater than zero
      args.updateTime = +new Date();
      if (this.currCur > 0) {
        if (this.hist[this.currCur - 1].paramName == args.paramName && (+new Date() - this.hist[this.currCur - 1].updateTime) < 1000) {
          this.hist[this.currCur - 1] = args;
          return;
        }
      }

      // Maximun 50 movements
      if (this.hist.length > 50) {
        this.hist.splice(0, hist.length - 50);
      }

      args.save = false;
      this.currCur = this.hist.push(args);
    },
    undo: function() {
      if (this.currCur < 1) { // No more history avaliable
        return;
      }
      var currentAction = this.hist[--this.currCur];
      Actions.setParam(currentAction);
    },
    redo: function() {
      if (this.currCur >= this.hist.length) {
        return;
      }
      var currentAction = this.hist[++this.currCur];
      Actions.setParam(currentAction);
    }
  }
  /* END Action class */

  // Exports

  window.__BOOT__ = __BOOT__
  window.__ERROR = __ERROR
  window.Actions = Actions
  window.isMobile = isMobile
  var Editor = Editor || {}
  Editor.getParamValue = function(param) {
    return Params.get(param)
  }
  window.Editor = Editor
})(window);
//(function(top) {
	function res_treatment(arr) {
		var l = arr.length;
		for (var i = 0; i < l; i++) {
			arr[i] = Math.round(arr[i] * 1000) / 1000;
		}
		return arr;
	};

	top.getCuadraticFunction = function(a, b, c, d, aa = 0, bb = 0.33, cc = 0.66, dd = 1) {
		var aaS = Math.pow(aa, 2);
		var bbS = Math.pow(bb, 2);
		var ccS = Math.pow(cc, 2);
		var ddS = Math.pow(dd, 2);
		var aaT = aaS * aa;
		var bbT = bbS * bb;
		var ccT = ccS * cc;
		var ddT = ddS * dd;
		var res = res_treatment(preSolve4(
			[aaT, bbT, ccT, ddT],
			[aaS, bbS, ccS, ddS],
			[aa, bb, cc, dd],
			[a, b, c, d]));
		//console.log(res);
		return function(x) {
			var _r = res[3];
			var xx = x;
			_r += res[2] * xx;
			xx *= x;
			_r += res[1] * xx;
			xx *= x;
			_r += res[0] * xx;
			return _r;
		}
		
	};

	function preSolve4(w, x, y, s) {
		var Aa = y[2] - y[3];
		var Ad = w[2] - w[3];
		var Ab = x[2] - x[3];
		var Ah = s[2] - s[3];
		var Ac = x[2] * y[3] - y[2] * x[3];
		var Af = w[2] * y[3] - y[2] * w[3];
		var Ag = w[2] * x[3] - x[2] * w[3];
		var Ai = s[2] * y[3] - y[2] * s[3];
		var Aj = s[2] * x[3] - x[2] * s[3];
		var Ak = w[2] * s[3] - s[2] * w[3];
		var Al = x[2] * s[3] - s[2] * x[3];
		var Am = y[2] * s[3] - s[2] * y[3];

		W = x[1] * Aa - y[1] * Ab + Ac;
		X = w[1] * Aa - y[1] * Ad + Af;
		Y = w[1] * Ab - x[1] * Ad + Ag;
		Z = w[1] * Ac - x[1] * Af + y[1] * Ag;
		_S  = w[0] * W - x[0] * X + y[0] * Y - Z;

		S = x[1] * Aa - y[1] * Ab + Ac;
		X = s[1] * Aa - y[1] * Ah + Ai;
		Y = s[1] * Ab - x[1] * Ah + Aj;
		Z = s[1] * Ac - x[1] * Ai + y[1] * Aj;
		_W = s[0] * S - x[0] * X + y[0] * Y - Z;

		W = s[1] * Aa - y[1] * Ah + Ai;
		S = w[1] * Aa - y[1] * Ad + Af;
		Y = w[1] * Ah - s[1] * Ad + Ak;
		Z = w[1] * Ai - s[1] * Af + y[1] * Ak;
		_X = w[0] * W - s[0] * S + y[0] * Y - Z;

		W = x[1] * Ah - s[1] * Ab + Al;
		X = w[1] * Ah - s[1] * Ad + Ak;
		S = w[1] * Ab - x[1] * Ad + Ag;
		Z = w[1] * Al - x[1] * Ak + s[1] * Ag;
		_Y = w[0] * W - x[0] * X + s[0] * S - Z;

		W = x[1] * Am - y[1] * Al + s[1] * Ac;
		X = w[1] * Am - y[1] * Ak + s[1] * Af;
		Y = w[1] * Al - x[1] * Ak + s[1] * Ag;
		S = w[1] * Ac - x[1] * Af + y[1] * Ag;
		_Z = w[0] * W - x[0] * X + y[0] * Y - s[0] * S;
		return [_W / _S, _X / _S, _Y / _S, _Z / _S];
	}

	function solve4(w, x, y, z, s) {
		var Aa = y[2] * z[3] - z[2] * y[3];
		var Ab = x[2] * z[3] - z[2] * x[3];
		var Ac = x[2] * y[3] - y[2] * x[3];
		var Ad = w[2] * z[3] - z[2] * w[3];
		var Af = w[2] * y[3] - y[2] * w[3];
		var Ag = w[2] * x[3] - x[2] * w[3];
		var Ah = s[2] * z[3] - z[2] * s[3];
		var Ai = s[2] * y[3] - y[2] * s[3];
		var Aj = s[2] * x[3] - x[2] * s[3];
		var Ak = w[2] * s[3] - s[2] * w[3];
		var Al = x[2] * s[3] - s[2] * x[3];
		var Am = y[2] * s[3] - s[2] * y[3];

		W = x[1] * Aa - y[1] * Ab + z[1] * Ac;
		X = w[1] * Aa - y[1] * Ad + z[1] * Af;
		Y = w[1] * Ab - x[1] * Ad + z[1] * Ag;
		Z = w[1] * Ac - x[1] * Af + y[1] * Ag;
		_S  = w[0] * W - x[0] * X + y[0] * Y - z[0] * Z;

		S = x[1] * Aa - y[1] * Ab + z[1] * Ac;
		X = s[1] * Aa - y[1] * Ah + z[1] * Ai;
		Y = s[1] * Ab - x[1] * Ah + z[1] * Aj;
		Z = s[1] * Ac - x[1] * Ai + y[1] * Aj;
		_W = s[0] * S - x[0] * X + y[0] * Y - z[0] * Z;

		W = s[1] * Aa - y[1] * Ah + z[1] * Ai;
		S = w[1] * Aa - y[1] * Ad + z[1] * Af;
		Y = w[1] * Ah - s[1] * Ad + z[1] * Ak;
		Z = w[1] * Ai - s[1] * Af + y[1] * Ak;
		_X = w[0] * W - s[0] * S + y[0] * Y - z[0] * Z;

		W = x[1] * Ah - s[1] * Ab + z[1] * Al;
		X = w[1] * Ah - s[1] * Ad + z[1] * Ak;
		S = w[1] * Ab - x[1] * Ad + z[1] * Ag;
		Z = w[1] * Al - x[1] * Ak + s[1] * Ag;
		_Y = w[0] * W - x[0] * X + s[0] * S - z[0] * Z;

		W = x[1] * Am - y[1] * Al + s[1] * Ac;
		X = w[1] * Am - y[1] * Ak + s[1] * Af;
		Y = w[1] * Al - x[1] * Ak + s[1] * Ag;
		S = w[1] * Ac - x[1] * Af + y[1] * Ag;
		_Z = w[0] * W - x[0] * X + y[0] * Y - s[0] * S;
		return [_W / _S, _X / _S, _Y / _S, _Z / _S];
	}
//})(window);
var Popup = Popup || {};
Popup.setHeader = function(header) {
	if (!header) {
		Popup.elements.popupHeader.style.display = "none";
	} else {
		Popup.elements.popupHeader.style.display = "";
		Popup.elements.popupHeader.innerText = header;
	}
}

Popup.elements = {};
Popup.onEnterCallback = null;

Popup.setBody = function(body) {
	Popup.elements.popupBody.innerText = body;
}

Popup.setBodyHTML = function(body) {
	Popup.elements.popupBody.innerHTML = body;
}

Popup.clearBottom = function() {
	Popup.elements.popupBottom.innerHTML = "";
}

Popup.addButton = function(text, callback, type) {
	var buttonDiv = document.createElement("div");
	buttonDiv.setAttribute("id", "__popup_button_" + (+ new Date()).toString("32") );
	buttonDiv.className = "button button-" + type;
	buttonDiv.append(document.createTextNode(text));
	buttonDiv.onclick = callback;
	Popup.elements.popupBottom.append(buttonDiv);
}

Popup.create = function() {
	if (document.getElementById("overlay")) {
		return;
	}
	Popup.elements.overlay = document.createElement("div");
	Popup.elements.overlay.setAttribute("id", "overlay");

	Popup.elements.popup = document.createElement("div");
	Popup.elements.popup.setAttribute("id", "popup");

	Popup.elements.popupContainer = document.createElement("div");
	Popup.elements.popupContainer.setAttribute("id", "popup-container");

	Popup.elements.popupHeader = document.createElement("div");
	Popup.elements.popupHeader.setAttribute("id", "popup-header");

	Popup.elements.popupBody = document.createElement("div");
	Popup.elements.popupBody.setAttribute("id", "popup-body");

	Popup.elements.popupBottom = document.createElement("div");
	Popup.elements.popupBottom.setAttribute("id", "popup-bottom");

	Popup.elements.popupContainer.append(Popup.elements.popupHeader);
	Popup.elements.popupContainer.append(Popup.elements.popupBody);
	Popup.elements.popupContainer.append(Popup.elements.popupBottom);

	Popup.elements.popup.append(Popup.elements.popupContainer);

	Popup.elements.overlay.append(Popup.elements.popup);

	document.body.append(Popup.elements.overlay);

	/*<div id="overlay">
			<div id="popup">
				<div id="popup-container">
					<div id="popup-header">
						HEADER
					</div>
					<div id="popup-body">
						BODY
					</div>
					<div id="popup-bottom">
					</div>
				</div>
			</div>
		</div>*/
}

Popup.visible = function(isVisible) {
	if (isVisible) {
		Popup.elements.overlay.style.display = "table";
		setTimeout(function() {
			Popup.elements.overlay.style.opacity = "1";
		}, 200);
	} else {
		Popup.elements.overlay.style.opacity = "0";
		setTimeout(function() {
			Popup.elements.overlay.style.display = "none";	
		}, 200);	
	}
}

Popup.show = function(data) {
	return new Promise((resolve, reject) => {
		Popup.create();
		Popup.clearBottom();
		Popup.setHeader(data.header);
		if (data.onEnterCallback && typeof data.onEnterCallback === 'function') {
			Popup.onEnterCallback = data.onEnterCallback
		}
		if (data.body) {
			Popup.setBody(data.body);
		}

		if (data.bodyHTML) {
			Popup.setBodyHTML(data.bodyHTML);
		}
		document.addEventListener('keydown', Popup.keydown);
		if (!data.preventClose) {
			Popup.addButton("Cerrar", Popup.hide, 'secondary');
		}

		if (data.buttons) {
			data.buttons.forEach(button => {
				Popup.addButton(button.text, button.callback, button.type || 'default');
			})
		}
		Popup.visible(true);
		resolve();
	})
}

Popup.keydown = function(e) {
	e = e || window.event;
	if (e.keyCode == 13) {
		if (Popup.onEnterCallback) {
			Popup.onEnterCallback()
			Popup.onEnterCallback = null // Clear callback
		} else {
			Popup.hide()
		} 
	}
}
Popup.hide = function() {
	document.removeEventListener('keydown', Popup.keydown);
	Popup.visible(false);
}
var UI = UI || {};
UI.scrollMenuListener = null;
UI.currentSelected = [];


UI.currentSubmenu = null;

UI.imageLoaded = false;
UI.isImageLoaded = function() {
	return UI.imageLoaded;
}

UI.setImageLoaded = function(isLoaded) {
	if(document.getElementById("canvas_info")) {
		document.getElementById("canvas_info").style.display = (isLoaded) ? "none" : "";
	}

	if(document.getElementById("image_main")) {
		document.getElementById("image_main").style.display =  (!isLoaded) ? "none" : "";
	}
	UI.imageLoaded = !!isLoaded;
}

UI.loadingHandler = function() {
	if (document.getElementById("loading-bar")) { // Only one instance is allower
		return;
	}
	var loadingElm = document.createElement("div");
	loadingElm.setAttribute("id", "loading-bar");

	var loadingBar = document.createElement("div");
	loadingBar.setAttribute("id", "loading-bar-container");

	var loadingBarLoader = document.createElement("div");
	loadingBarLoader.setAttribute("id", "loading-bar-loader");
	loadingBar.append(loadingBarLoader);
	loadingElm.append(loadingBar);
	document.body.append(loadingElm);
	return {
		load: function() {

		},
		set: function(x) {
			if (x > 100) { x = 100; }
			if (x < 0) { x = 0; }
			// Clear ui update
			setTimeout(function() {
				document.getElementById("loading-bar-loader").style.width = x + "%";
			}, 0);
		},
		end: function() {
			this.set(100);
			setTimeout(function() {
				document.body.removeChild(loadingElm);
			}, 200);
		}
	}
};

UI.closeSubmenu = function(menu) {
	document.getElementById("submenu_" + menu).style.transform = "translateY(-100%)";
	setTimeout(function() {
		document.getElementById("submenu_" + menu).style.display = "none";
	}, 200); // In order to perform transform before display: none
	
};

UI.openSubmenu = function(menu) {
	var subMenuElm = document.getElementById("submenu_" + menu);
	var j = subMenuElm.children.length;
	var i = 0;
	var selectedElm = subMenuElm.children[0]; // select first from default
	while (i < j) {
		if (subMenuElm.children[i].className.indexOf("selected") > -1) {
			selectedElm = subMenuElm.children[i];
			break;
		}
		i++;
	}

	subMenuElm.style.display = "block";
	
	// When open menu, select the selected element on submenu
	UI.selectAdjust(selectedElm);

	setTimeout(function() {
		subMenuElm.style.transform = "translateY(0%)";
	}, 200); // In order to perform display: block before translateY
	
}
UI.selectAdjust = function(that) {

	if (that.getAttribute("data-submenu")) {
		if (UI.currentSubmenu && UI.currentSubmenu !== that.getAttribute("data-submenu")) {
			UI.closeSubmenu(UI.currentSubmenu);
		}
		// Show submenu
		UI.currentSubmenu = that.getAttribute("data-submenu");
		UI.openSubmenu(that.getAttribute("data-submenu"));
		return;
	}

	// Close when menu changes, but prevent when in submenu
	if (UI.currentSubmenu && that.parentElement.className.indexOf("submenu") < 0) {
		UI.closeSubmenu(UI.currentSubmenu);
	}

	

	if (that.getAttribute("data-item")) {
		current_adjust.paramName = that.getAttribute("data-item");
	}
	current_adjust.max = parseFloat(that.getAttribute("max"));
	current_adjust.min = parseFloat(that.getAttribute("min"));
	current_adjust.callbacks = that.getAttribute("data-callback") || "";

	var amountElm = document.getElementById("cantidad");
  if (amountElm) {
    amountElm.innerHTML = Locale.get(current_adjust.paramName) + ": " + Math.round(Params.get(current_adjust.paramName) * 100) / 100;
  }

}

UI.dataActionClick = function(event) {
	var that = event.target;
	console.log(event.target);
	if (that.getAttribute("data-action")) {
		var action = that.getAttribute("data-action")
		window.Actions[action]();
	}

};

// Double click => set default
UI.rangeDblClick = function(event) {
	event.stopPropagation();
	this.value = Params.getDefault(this.getAttribute("data-item"));
	Actions.setParam({
    paramName: this.getAttribute("data-item"),
    value: parseFloat(this.value),
    callbacks: this.getAttribute("data-callback"),
    save: true
  });
  event.preventDefault();
};

UI.moveRange_timer = {
	to: null,
	param: null
};

UI.moveRange = function(event) {
	
	// Set params
	if (UI.moveRange_timer.to && UI.moveRange_timer.to == this.getAttribute("data-item")) {
		clearTimeout(UI.moveRange_timer.to)
	}

	UI.moveRange_timer.param = this.getAttribute("data-item");
	UI.moveRange_timer.to = setTimeout(() => {
		Actions.setParam({
	    paramName: this.getAttribute("data-item"),
	    value: parseFloat(this.value),
	    callbacks: this.getAttribute("data-callback"),
	    save: true
	  });
	}, 30);
};



UI.scrollMenu = function(event) {

	var menuElm = event.target;
	if (event.target.className.indexOf("menu") < 0) {
		return;
	}
	var selection = Math.round(__NUM_OF_MENU_ITEMS__ * this.scrollLeft / document.body.offsetWidth);
	selection += __MENU_ITEMS_PADDING__;				

	if (UI.scrollMenuListener) {
		clearTimeout(UI.scrollMenuListener);
	}

	// Set the position
	var that = this;
	UI.scrollMenuListener = setTimeout(function() {
		UI.selectMenuItem(selection, menuElm);
	}, 150);
}



UI.clickMenuContainer = function(event) {
	if (this.parentElement.classList.contains("open")) {
		this.parentElement.classList.remove("open");
	} else {
		this.parentElement.classList.add("open");
	}
}

UI.dropFile = function(event) {
		event = event || window.event;
	  event.preventDefault();
	  event.stopPropagation(); 
	  document.body.style.opacity = 1;
	  try {
	  	loadImageFromUrl(URL.createObjectURL(event.dataTransfer.files[0]));
	  } catch (err) {
	  	console.log(err);
	  	__ERROR("No se pudo cargar la imagen al arrastrarla, por favor, utilice el botón de abrir.");
	  }
}
const __SHADERS__ = {
      VERTEX: `attribute vec2 a_position;attribute vec2 a_texCoord;uniform vec2 u_resolution;varying vec2 v_texCoord;void main() { vec2 dist = a_position / u_resolution; gl_Position = vec4( (dist * 2.0 - 1.0) * vec2(1, -1), 0, 1); v_texCoord = a_texCoord;}`,
      FRAGMENT: `/** * David Iglesias. All rights reserved */ precision mediump float; uniform sampler2D u_image; uniform vec2 u_textureSize; uniform float u_kernel[25]; uniform float u_kernelWeight; uniform sampler2D u_lut; uniform float u_saturation; uniform float u_brightness; uniform float u_exposure; uniform float u_contrast; uniform float u_dehaze; uniform float u_atmosferic_light; uniform float u_masking; uniform vec3 u_temptint[3]; uniform float u_bAndW; uniform float u_hdr; varying vec2 v_texCoord; void main() { vec2 pixel_size = vec2(1.0, 1.0) / u_textureSize; vec3 center = texture2D(u_image, v_texCoord).rgb; vec4 colorSum = texture2D(u_image, v_texCoord + pixel_size * vec2(-2, -2)) * u_kernel[0] + texture2D(u_image, v_texCoord + pixel_size * vec2( -1, -2))* u_kernel[1] + texture2D(u_image, v_texCoord + pixel_size * vec2( 0, -2)) * u_kernel[2] + texture2D(u_image, v_texCoord + pixel_size * vec2( 1, -2)) * u_kernel[3] + texture2D(u_image, v_texCoord + pixel_size * vec2( 2, -2)) * u_kernel[4] + texture2D(u_image, v_texCoord + pixel_size * vec2( -2, -1))* u_kernel[5] + texture2D(u_image, v_texCoord + pixel_size * vec2(-1, -1)) * u_kernel[6] + texture2D(u_image, v_texCoord + pixel_size * vec2( 0, -1)) * u_kernel[7] + texture2D(u_image, v_texCoord + pixel_size * vec2( 1, -1)) * u_kernel[8] + texture2D(u_image, v_texCoord + pixel_size * vec2( 2, -1)) * u_kernel[9] + texture2D(u_image, v_texCoord + pixel_size * vec2( -2, 0)) * u_kernel[10] + texture2D(u_image, v_texCoord + pixel_size * vec2(-1, 0)) * u_kernel[11] + texture2D(u_image, v_texCoord + pixel_size * vec2( 0, 0)) * u_kernel[12] + texture2D(u_image, v_texCoord + pixel_size * vec2( 1, 0)) * u_kernel[13] + texture2D(u_image, v_texCoord + pixel_size * vec2( 2, 0)) * u_kernel[14] + texture2D(u_image, v_texCoord + pixel_size * vec2(-2, 1)) * u_kernel[15] + texture2D(u_image, v_texCoord + pixel_size * vec2(-1, 1)) * u_kernel[16] + texture2D(u_image, v_texCoord + pixel_size * vec2( 0, 1)) * u_kernel[17] + texture2D(u_image, v_texCoord + pixel_size * vec2( 1, 1)) * u_kernel[18] + texture2D(u_image, v_texCoord + pixel_size * vec2( 2, 1)) * u_kernel[19] + texture2D(u_image, v_texCoord + pixel_size * vec2(-2, 2)) * u_kernel[20] + texture2D(u_image, v_texCoord + pixel_size * vec2(-1, 2)) * u_kernel[21] + texture2D(u_image, v_texCoord + pixel_size * vec2( 0, 2)) * u_kernel[22] + texture2D(u_image, v_texCoord + pixel_size * vec2( 1, 2)) * u_kernel[23] + texture2D(u_image, v_texCoord + pixel_size * vec2( 2, 2)) * u_kernel[24]; vec3 rgb_pix = mix(center, (colorSum.rgb / u_kernelWeight), u_masking); float _max = max(rgb_pix.r, max(rgb_pix.g, rgb_pix.b)); float _min = min(rgb_pix.r, min(rgb_pix.g, rgb_pix.b)); vec2 sv_pixel = vec2(1.0 - _min / _max, _max); sv_pixel.y = clamp(texture2D(u_lut, vec2(sv_pixel.y, 0.0)).a, 0.0, 1.0); if (u_saturation != 0.0) { sv_pixel.x *= (1.0 + u_saturation); } sv_pixel.x = clamp(sv_pixel.x, 0.0, 1.0); if (u_brightness != 0.0) { sv_pixel.y = pow(sv_pixel.y, 1.0 - u_brightness * 0.6); } if (u_hdr != 0.0) { sv_pixel.y = mix(sv_pixel.y, clamp(1.0 - pow(1.0 - pow(sv_pixel.y, 0.3), 0.42), 0.0, 1.0), u_hdr); } sv_pixel = clamp(sv_pixel, 0.0, 1.0); if (sv_pixel.x > 0.0) { float k = - sv_pixel.x / (1.0 - _min / _max); rgb_pix = (_max - rgb_pix) * k + _max; rgb_pix *= sv_pixel.y / _max; } else { rgb_pix.r = rgb_pix.g = rgb_pix.b = sv_pixel.y; } if (u_dehaze != 0.0) { float t = 1.0 / 25.0; vec4 center = texture2D(u_image, v_texCoord); vec2 pixel_size = vec2(1.0, 1.0) / u_textureSize; float dark = 1.0; const int radius = 1; for (int ii = -radius; ii <= radius; ii++ ) { for(int jj = -radius; jj <= radius; jj++) { vec4 pix = texture2D(u_image, v_texCoord + pixel_size * vec2( ii, jj)); float _min = min(pix.r, min(pix.g, pix.b)); if (dark > _min) { dark = _min; } } } float darkPix = min(center.r, min(center.g, center.b)); float diff = abs(darkPix - dark); float mask = pow(diff, 3.0); dark = mix(darkPix, dark, mask); float mm = max(1.0 - dark, 0.2); rgb_pix = mix(rgb_pix, ((rgb_pix - u_atmosferic_light) / mm + u_atmosferic_light), u_dehaze); } rgb_pix += u_exposure; rgb_pix = clamp(rgb_pix, 0.0, 1.0); float contrast = u_contrast + 1.0; rgb_pix = contrast * (rgb_pix - 0.5) + 0.5; rgb_pix *= u_temptint[0]; float mono = dot(rgb_pix, vec3(0.2126, 0.7152, 0.0722)); rgb_pix += mix(u_temptint[2], u_temptint[1], mono); if (u_bAndW != 0.0) { rgb_pix = mix(rgb_pix, vec3(mono, mono, mono), u_bAndW); } gl_FragColor = vec4(rgb_pix, 1.0); }`
    }
/* Locale class */

var Locale = Locale || {};
Locale.dict = {
  "es": {
    "exposure": "Exposición",
    "contrast": "Contraste",
    "brightness": "Brillo",
    "whites": "Claros",
    "highlights": "Luces",
    "shadows": "Sombras",
    "blacks": "Oscuros",
    "temperature": "Temperatura",
    "tint": "Matiz",
    "saturation": "Saturación",
    "vibrance": "Vibrancia",
    "bAndW": "Blanco y negro",
    "sharpen": "Detalles",
    "sharpen_radius": "Radio de detalle",
    "masking": "Máscara",
    "radiance": "Radiancia",
    "dehaze": "Niebla",
    "atmosferic_light": "Luz atmosférica",
    "hdr": "Alto rango dinámico",
    "lightColor": "Color",
    "lightFill": "Cantidad",
    "lightSat": "Cantidad",
    "darkColor": "Color",
    "darkFill": "Cantidad",
    "darkSat": "Cantidad",
    "image_no_loaded": "No hay ninguna imagen cargada. Para editar, cargue una imagen.",
    "image_save_title": "¿Desea guardar la imagen?",
    "image_save_text": "Nombre de la imagen (Resolución máxima: 10Mpx) :"
  }
};
Locale.current = "es";
Locale.get = function(value) {
  if (Locale.dict[Locale.current][value]) {
    return Locale.dict[Locale.current][value];
  }
  return value;
}

var Params = Params || {};
Params.params = {
  hdr: 0,
  exposure: 0,
	temperature: 0,
  tint: 0,
	brightness: 0, // [0-100]
	saturation: 0, // [0-100]
	contrast: 0, // [0-100]
	sharpen: 0,
	masking: 0.5,
	sharpen_radius: 1,
	radiance: 0,
	highlights: 0,
	shadows: 0,
	whites: 0,
	blacks: 0,
	dehaze: 0,
  bAndW: 0,
	atmosferic_light: 0.7,
  lightFill: 0,
  lightColor: 0,
  lightSat: 1,
  darkFill: 0,
  darkColor: 0,
  darkSat: 1
};

Params.default = (function(par) {
  var _default = {};
  Object.keys(par).forEach(key => {
    _default[key] = par[key];
  })
  return _default;
})(Params.params);

Params.get = function(name) {
	return Params.params[name];
}

Params.reset = function(name) {
	Object.keys(Params.params).forEach(key => {
	  Params.params[key] = Params.default[key];
	});

}

Params.set = function(name, val) {
	Params.params[name] = parseFloat(val);
}

Params.getDefault = function(name) {
	return Params.default[name];
}
window.addEventListener("onload", function() {
	if('serviceWorker' in navigator) {
		try {
	  	navigator.serviceWorker.register('/serviceWorker.js')
	  	console.log("NONE")
	  } catch(err) {
	  	// Error not handled
	  }
	}
});

var __NUM_OF_MENU_ITEMS__ = 5;
var __MENU_ITEMS_PADDING__ = Math.floor( (__NUM_OF_MENU_ITEMS__ - 1 )/ 2);
var CURRENT_IMAGE_TRANSFORMATIONS = {
	x: 0,
	y: 0,
	scale: 1,
	originX: null,
	originY: null,
	deltaX: 0,
	deltaY: 0
};

window.onerror = function(errorMessage, errorUrl, errorLine) {
	__ERROR("Error: " + errorMessage + " en la url: " + errorUrl + ", en la Línea:" + errorLine);
};



function setElementDraggable(elmnt) {
	var iniX = 0,
			iniY = 0;
  elmnt.addEventListener("mousedown", dragMouseDown);

  

  function dragMouseDown(ev) {
    var e = ev || window.event;
    e.preventDefault();

    // get the mouse cursor position when starts:
    iniX = e.clientX;
    iniY = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
  	if (elmnt.className.indexOf("scaled") < 0) {
  		return;
  	}
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    var newX = iniX - e.clientX;
    var newY = iniY - e.clientY;
    iniX = e.clientX;
    iniY = e.clientY;
    
    elmnt.style.top = (elmnt.offsetTop - newY) + "px";
    elmnt.style.left = (elmnt.offsetLeft - newX) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

window.addEventListener("load", function(event) {
	// Check mobile
  if (isMobile()) {
  	document.body.innerHTML = "Loading...";
  	document.body.style.background = "#000";
  	location.href="mobile.html";
  	return;
  }



  var dataActionElm = document.getElementsByClassName("data-action");
  var i = dataActionElm.length;
  while (i --) {
  	dataActionElm[i].addEventListener("click", UI.dataActionClick);
  }
  
  var imageElm = document.getElementById("image_main");
  setElementDraggable(imageElm);
  
  


  var menu_container_openers = document.getElementsByClassName("menu-container-title");
  i = menu_container_openers.length;
  while (i--) {
  	menu_container_openers[i].addEventListener("click", UI.clickMenuContainer);	
  }

  var range = document.getElementsByClassName("range");
  i = range.length;
  while (i--) {
    range[i].addEventListener("dblclick", UI.rangeDblClick);
  	range[i].addEventListener("input", UI.moveRange);	
  }

/*  
  document.addEventListener("keydown", e => {
  	e = e || window.event;
  	// Control key pressed
  	if (e.ctrlKey) {
  		if (e.keyCode === 89) { // CNTRL + Y

  		}
  		if (e.keyCode === 90) { // CNTRL + Z

  		}
  	}
  });*/
  document.addEventListener("drop", UI.dropFile);
  document.addEventListener("dragover", event => { event.preventDefault(); event.stopPropagation(); document.body.style.opacity = 0.7; } );
  document.addEventListener("dragend", event => { event.preventDefault(); event.stopPropagation(); document.body.style.opacity = 1; });


  // Image open action
  document.getElementById("image-open").addEventListener("click", function() {
		document.getElementById("image_data").click(); 	
  });

  (function (imageElm) {
	  var lastClick = 0;
	  imageElm.addEventListener("click", (event) => {
	    if (+ new Date() - lastClick < 300) { // Double click
	      
	      if (imageElm.className.indexOf("scaled") > -1) {
	        imageElm.className = imageElm.className.replace(" scaled", "");
	        imageElm.style.position = "";
	        imageElm.style.transformOrigin = "";
					imageElm.style.transform = "";
	      } else {
	        imageElm.className += " scaled";
	        imageElm.style.top = imageElm.offsetLeft + "px";
    			imageElm.style.left = imageElm.offsetLeft + "px";
	        imageElm.style.position = "absolute";
	        
          imageElm.style.transformOrigin = " " + (event.clientX - imageElm.offsetLeft) + "px " + (event.clientY - imageElm.offsetTop) + "px";
					imageElm.style.transform = "scale(2.1)";
	      }
	      
	      return;
	    }
	    
	    lastClick = + new Date();
	    
	  })
	})(imageElm);

  // Download image action
  document.getElementById("image-save").addEventListener("click", async function() {
  	await window.Actions.download({ limit: 2000 }); // limited to 2000
  });

  __BOOT__();
});